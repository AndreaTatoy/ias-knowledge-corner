# **Cross-Site Scripting (XSS) (CWE-79)**

## **What is Cross-Site Scripting (XSS)?**

* **Definition:** A web security vulnerability that allows an attacker to inject client-side scripts (typically **JavaScript**) into a web page. When a victim views that page, their browser executes the script, thinking it's legitimate code from the trusted website.  
* **Root Cause (CWE-79):** **Improper Neutralization of Input During Web Page Generation**. The application accepts untrusted data and includes it in the HTML output without properly treating it as data, allowing the browser to interpret it as code.  
* **The Same-Origin Policy:** The attack's main goal is to **circumvent the Same-Origin Policy (SOP)**. SOP is a browser mechanism that prevents a script from one domain (e.g., attacker.com) from accessing data from another domain (e.g., bank.com). By injecting a script *into* the trusted domain, the attacker's script gains the same privileges as the legitimate application code.

### **The Three Main Types of XSS**

1. **Stored (Persistent) XSS:** The malicious script is permanently stored on the target server (e.g., in a database, comment, or forum post). Every user who loads that page executes the payload.  
2. **Reflected XSS:** The malicious script is "reflected" immediately from the server. The attacker typically sends a malicious link (e.g., in an email or chat) containing the payload in the URL (a query parameter). The server reads the parameter and reflects it into the response.  
3. **DOM-based XSS:** The vulnerability exists entirely on the client-side within the JavaScript code itself. The server is not involved in processing the malicious data. The script is executed when the client-side code dynamically updates the Document Object Model (DOM) using untrusted input (e.g., from a URL fragment or input field).

## **Attack Impact and Consequences**

Since the malicious script executes within the victim's browser, it inherits the permissions of the vulnerable site and can perform actions on the user's behalf.

* **Session Hijacking (Cookie Theft):** The injected script can steal the user's **session cookies** and send them to the attacker's server. The attacker can then use this stolen cookie to impersonate the victim and gain unauthorized access to their account (as noted in the document's ForkCMS example).  
* **Keystroke Logging:** Capturing the victim's keystrokes, including passwords, credit card numbers, and messages.  
* **Defacement and Phishing:** Modifying the content of the page (defacement) or displaying a fake login prompt to steal credentials (phishing).  
* **Malware Download:** Redirecting the victim's browser to an attacker-controlled site hosting malware.

## **Mitigation (The Strongest Defense)**

Unlike SQL Injection which uses **Prepared Statements**, XSS relies heavily on **Output Encoding** and **Input Validation**.

### **1\. Output Encoding / Escaping (Primary Defense)**

This is the **most crucial step**. Before displaying user-controllable data in the browser, treat it strictly as **data**, not as code.

* The application should encode characters that have special meaning in HTML, such as:  
  * \< becomes \&lt;  
  * \> becomes \&gt;  
  * " becomes \&quot;  
* This ensures the browser renders the malicious script literally as text (e.g., \<script\>alert(1)\</script\>) instead of executing it. The encoding must be **context-aware** (e.g., if rendering in an HTML attribute, use attribute encoding).

### **2\. Input Validation and Sanitization (Defense-in-Depth)**

* **Input Validation:** Use strict allowlists to check user input. If you expect a username, reject any input containing \< or \>.  
* **Sanitization:** For applications that *must* allow some HTML (like rich text editors), use a dedicated, secure **sanitizer library** (like OWASP Java HTML Sanitizer or DOMPurify for client-side) to remove dangerous tags (like \<script\>, onerror, etc.) while preserving safe formatting tags (like \<b\> or \<i\>).

### **3\. Content Security Policy (CSP)**

* **CSP** is an HTTP response header that tells the browser which dynamic resources (like scripts and styles) are trusted and allowed to load.  
* A strong CSP can block an injected script from running or prevent it from communicating with an attacker's server, even if the application suffers from an XSS flaw.